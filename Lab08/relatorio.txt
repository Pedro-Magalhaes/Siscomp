ALUNO: Pedro Felipe Santos Magalhães – 1611074


QUESTÃO 1)  Execute o programa dado (exemplo de uso 
de semáforos) e verifique / explique sua 
execução.
-----------------------------------------------------
ARQUIVO.C

/*** CÓDIGO IDENTICO AO DADO NA TAREFA****/
#include <sys/sem.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
union semun
{
	int	val;
	struct semid_ds *buf;
	ushort *array;
};
// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue( int semId);
// operação P
int semaforoP( int semId);
//operação V
int semaforoV( int semId);

int main ( int argc, char* argv[])
{
	int i;
	char letra = 'o';
	int	semId;
	if	(argc > 1)
	{
		semId = semget (8752, 1, 0666 | IPC_CREAT);
		setSemValue(semId);
		letra =	'x';
		sleep (2);
	}
	else
	{
		while
		((semId = semget (8752, 1, 0666)) < 0)
		{
			putchar ('.');
			fflush(stdout);
			sleep (1);
		}
	}
	for	(i=0; i<10; i++)
	{
		semaforoP(semId);
		putchar (toupper(letra)); fflush(stdout);
		sleep (rand() %3);
		putchar (letra); fflush(stdout);
		semaforoV(semId);
		sleep (rand() %2);
	}
	printf ("\nProcesso %d terminou\n", getpid());
	if(argc > 1)
	{
		sleep(10);
		delSemValue(semId);
	}
	return 0;
}
int setSemValue(int semId)
{
	union semun semUnion;
	semUnion.val = 1;
	return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
	union semun semUnion;
	semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP( int semId)
{
	struct
	sembuf semB;
	semB.sem_num = 0;
	semB.sem_op = -	1;
	semB.sem_flg = SEM_UNDO;
	semop(semId, &semB, 1);
	return	0;
}
int semaforoV(int semId)
{
	struct sembuf semB;
	semB.sem_num = 0;
	semB.sem_op = 1;
	semB.sem_flg = SEM_UNDO;
	semop(semId, &semB, 1);
	return	0;
}


-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
c1611074@joatinga ~/Documents/pedro/Siscomp/Lab08$gcc -Wall -o l01 lab01.c 
c1611074@joatinga ~/Documents/pedro/Siscomp/Lab08$./l01 &
[1] 2973
.c1611074@joatinga ~/Documents/pedro/Siscomp/Lab08$./.l01 .a

-----------------------------------------------------
RESULTADO

.c1611074@joatinga ~/Documents/pedro/Siscomp/Lab08$./.l01 .a
OoOoXxOoXxOoXxOoXxOoXxOoXxOoXxOoOo
XProcesso 2973 terminou
xXxXx
Processo 2980 terminou
[1]+  Done                    ./l01



-----------------------------------------------------
CONCLUSÃO
Apesar de os dois processos estarem concorrendo pela cpu, como as áreas criticas são
bloqueadas por semáforo os processos executam de forma síncrona, mesmo que um
deles esteja em sleep o outro fica bloqueado também no semáforo e só consegue imprimir
quando o processo que ativou o semáfora volta do sleep e imprime sua última letra.
Pode ocorrer de um imprimir mais de uma vez seguida dependendo do tempo de sleep dos 
processos após liberarem o semáforo e por isso o termino de cada processo pode variar.


/**********************************************************/
 2) Produtor-Consumidor
Escreva um programa formado por dois 
processos concorrentes, leitor e impressor, que 
compartilham uma área de trabalho (memória) 
executando um loop infinito. Para sincronizar as 
suas ações, eles fazem uso de semáforos. 

O processo leitor fica lendo caracteres da entrada 
padrão e colocando em um buffer de 16 
posições. Quando o buffer está cheio o processo 
impressor deve imprimi-lo na saída padrão.
-----------------------------------------------------
ARQUIVO.C

/*ReaderLab02.c*/

#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#define OPENMODE (O_RDONLY)
#define FIFO "minhaFifo"
int main (void)
{
    int fpFIFO;
    char msg[50];
    if (access(FIFO, F_OK) == -1)
    {
        if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0)
        {
            fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
            return -1;
        }
    }
    puts ("Abrindo FIFO");
    if ((fpFIFO = open (FIFO, OPENMODE)) < 0)
    {
        fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
        return -2;
    }
    puts ("Começando a ler...");
    while (read (fpFIFO, msg, 50) > 0)
    {
        printf("%s\n",msg);
    }
    
    puts ("Fim da leitura");
    close (fpFIFO);
    return 0;
}

/*	WriterLab02.c	*/
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#define OPENMODE (O_WRONLY)
#define FIFO "minhaFifo"
int main (void)
    {
    int fpFIFO;
    char mensagem[50] = "Melancia sem caroço";
    if (access(FIFO, F_OK) == -1)
    {
        if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0)
        {
            fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
            return -1;
        }
    }
    puts ("Abrindo FIFO");
    if ((fpFIFO = open (FIFO, OPENMODE)) < 0)
    {
        fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
        return -2;
    }
    //puts ("Começando a escrever...");
    while(strcmp(mensagem,"done")!=0)
    {
        printf("Digite algo, termina com 'done'\n");
        scanf("%s",mensagem);
        write(fpFIFO, mensagem, strlen(mensagem)+1);

    }
    
    puts ("Fim da escrita");
    close (fpFIFO);
    return 0;
}
-----------------------------------------------------

COMPILAÇÃO E EXECUÇÃO
pedro@pedro-TA990FXE:~/Documents/Siscomp/Lab07$ gcc -Wall -o Wl02 WriterLab02.c 
pedro@pedro-TA990FXE:~/Documents/Siscomp/Lab07$ gcc -Wall -o Rl02 ReaderLab02.c

-----------------------------------------------------
RESULTADO
/**** CONSOLE WRITER (Lê e escreve no fifo) ****/
pedro@pedro-TA990FXE:~/Documents/Siscomp/Lab07$ ./Wl02 
Abrindo FIFO
Digite algo, termina com 'done'
Ola
Digite algo, termina com 'done'
ola
Digite algo, termina com 'done'
so
Digite algo, termina com 'done'
posso
Digite algo, termina com 'done'
escrever
Digite algo, termina com 'done'
sem 
Digite algo, termina com 'done'
espaco
Digite algo, termina com 'done'
\n
Digite algo, termina com 'done'
done
Fim da escrita

/**** CONSOLE Reader (Lê fifo e escreve na tela) ****/
pedro@pedro-TA990FXE:~/Documents/Siscomp/Lab07$ ./Rl02 
Abrindo FIFO
Começando a ler...
Ola
ola
so
posso
escrever
sem
espaco
\n
done
Fim da leitura


-----------------------------------------------------
CONCLUSÃO
Consegui fazer um programa ler o que foi digitado no console e passar isso pro fifo
em seguida o programa que lia o fifo escrevia na tela o que foi lido e aguardava
o writer escrever mais. Fiz leitura somente de palavras sem espaço pra simplificar
(usei scanf("%s"))


/**********************************************************/


